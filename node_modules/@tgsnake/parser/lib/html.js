"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.parse = void 0;
// Tgsnake - Telegram MTProto framework developed based on gram.js.
// Copyright (C) 2021 Butthx <https://guthub.com/butthx>
//
// This file is part of Tgsnake
//
// Tgsnake is a free software : you can redistribute it and/or modify
//  it under the terms of the MIT License as published.
var htmlparser2_1 = require("htmlparser2");
var Entities_1 = require("./Entities");
function stripText(text, entities) {
    if (!entities || !entities.length) {
        return text.trim();
    }
    while (text && text[text.length - 1].trim() === "") {
        var e = entities[entities.length - 1];
        if (e.offset + e.length == text.length) {
            if (e.length == 1) {
                entities.pop();
                if (!entities.length) {
                    return text.trim();
                }
            }
            else {
                e.length -= 1;
            }
        }
        text = text.slice(0, -1);
    }
    while (text && text[0].trim() === "") {
        for (var i = 0; i < entities.length; i++) {
            var e = entities[i];
            if (e.offset != 0) {
                e.offset--;
                continue;
            }
            if (e.length == 1) {
                entities.shift();
                if (!entities.length) {
                    return text.trimLeft();
                }
            }
            else {
                e.length -= 1;
            }
        }
        text = text.slice(1);
    }
    return text;
}
var HTMLParser = /** @class */ (function () {
    function HTMLParser() {
        this.text = "";
        this.entities = [];
        this._buildingEntities = new Map();
        this._openTags = [];
        this._openTagsMeta = [];
    }
    HTMLParser.prototype.onopentag = function (name, attributes) {
        this._openTags.unshift(name);
        this._openTagsMeta.unshift(undefined);
        var EntityType;
        var args = {};
        if (name == "strong" || name == "b") {
            EntityType = "bold";
        }
        else if (name == "em" || name == "i") {
            EntityType = "italic";
        }
        else if (name == "u") {
            EntityType = "underline";
        }
        else if (name == "del" || name == "s") {
            EntityType = "strike";
        }
        else if (name == "blockquote") {
            EntityType = "blockquote";
        }
        else if (name == "code") {
            var pre = this._buildingEntities.get("pre");
            if (pre && pre.type == "pre") {
                try {
                    pre.language = attributes.class.slice("language-".length, attributes.class.length);
                }
                catch (e) { }
            }
            else {
                EntityType = "code";
            }
        }
        else if (name == "pre") {
            EntityType = "pre";
            args["language"] = "";
        }
        else if (name == "a") {
            var url = attributes.href;
            if (!url) {
                return;
            }
            var mention = /tg:\/\/user\?id=(\d+)/gi.exec(url);
            if (url.startsWith("mailto:")) {
                url = url.slice("mailto:".length, url.length);
                EntityType = "email";
            }
            else if (mention) {
                (EntityType = "mentionName"),
                    (args["userId"] = BigInt(String(mention[1])));
                url = undefined;
            }
            else {
                EntityType = "textUrl";
                args["url"] = url;
                url = undefined;
            }
            this._openTagsMeta.shift();
            this._openTagsMeta.unshift(url);
        }
        else if (name == "spoiler" ||
            (name == "span" &&
                attributes.class &&
                attributes.class == "tg-spoiler") ||
            name == "sp" ||
            name == "tg-spoiler") {
            EntityType = "spoiler";
        }
        if (EntityType && !this._buildingEntities.has(name)) {
            this._buildingEntities.set(name, new Entities_1.Entities(__assign({ offset: this.text.length, length: 0, type: EntityType }, args)));
        }
    };
    HTMLParser.prototype.ontext = function (text) {
        var e_1, _a;
        var previousTag = this._openTags.length > 0 ? this._openTags[0] : "";
        if (previousTag == "a") {
            var url = this._openTagsMeta[0];
            if (url) {
                text = url;
            }
        }
        try {
            for (var _b = __values(this._buildingEntities), _c = _b.next(); !_c.done; _c = _b.next()) {
                var _d = __read(_c.value, 2), tag = _d[0], entity = _d[1];
                entity.length += text.length;
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_1) throw e_1.error; }
        }
        this.text += text;
    };
    HTMLParser.prototype.onclosetag = function (tagname) {
        this._openTagsMeta.shift();
        this._openTags.shift();
        var entity = this._buildingEntities.get(tagname);
        if (entity) {
            this._buildingEntities.delete(tagname);
            this.entities.push(entity);
        }
    };
    HTMLParser.prototype.onattribute = function (name, value, quote) { };
    HTMLParser.prototype.oncdataend = function () { };
    HTMLParser.prototype.oncdatastart = function () { };
    HTMLParser.prototype.oncomment = function (data) { };
    HTMLParser.prototype.oncommentend = function () { };
    HTMLParser.prototype.onend = function () { };
    HTMLParser.prototype.onerror = function (error) { };
    HTMLParser.prototype.onopentagname = function (name) { };
    HTMLParser.prototype.onparserinit = function (parser) { };
    HTMLParser.prototype.onprocessinginstruction = function (name, data) { };
    HTMLParser.prototype.onreset = function () { };
    return HTMLParser;
}());
function inRange(x, min, max) {
    return (x - min) * (x - max) <= 0;
}
function unEscape(text) {
    return text
        .replace(/\&amp\;/gm, "&")
        .replace(/\&lt\;/gm, "<")
        .replace(/\&rt\;/gm, ">");
}
function parse(html) {
    if (!html) {
        return [html, []];
    }
    var handler = new HTMLParser();
    var parser = new htmlparser2_1.Parser(handler);
    parser.write(html);
    parser.end();
    var text = stripText(handler.text, handler.entities);
    var entities = handler.entities;
    entities.sort(function (a, b) {
        return a.offset - b.offset;
    });
    // remove any entities if it inside code-style.
    for (var im = 0; im < entities.length; im++) {
        var em = entities[im];
        var pm = entities[im - 1];
        var nm = entities[im + 1];
        if (nm) {
            if (inRange(nm.offset, em.offset, em.offset + em.length)) {
                if (em.type == "code") {
                    if (nm.type !== "spoiler")
                        entities.splice(im + 1, 1);
                }
                else if (nm.type == "code") {
                    if (em.type !== "spoiler")
                        entities.splice(im, 1);
                }
            }
        }
        else if (pm) {
            if (inRange(pm.offset, em.offset, em.offset + em.length)) {
                if (em.type == "code") {
                    if (pm.type !== "spoiler")
                        entities.splice(im - 1, 1);
                }
                else if (pm.type == "code") {
                    if (em.type !== "spoiler")
                        entities.splice(im, 1);
                }
            }
        }
    }
    return [unEscape(text), entities];
}
exports.parse = parse;
