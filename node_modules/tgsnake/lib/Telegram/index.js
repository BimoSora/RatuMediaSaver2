"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Telegram = void 0;
// Tgsnake - Telegram MTProto framework developed based on gram.js.
// Copyright (C) 2021 Butthx <https://github.com/butthx>
//
// This file is part of Tgsnake
//
// Tgsnake is a free software : you can redistribute it and/or modify
//  it under the terms of the MIT License as published.
var GetEntity_1 = require("./Users/GetEntity");
var sendMessage_1 = require("./Messages/sendMessage");
var DeleteMessages_1 = require("./Messages/DeleteMessages");
var EditMessage_1 = require("./Messages/EditMessage");
var ForwardMessages_1 = require("./Messages/ForwardMessages");
var GetMessages_1 = require("./Messages/GetMessages");
var GetMessagesViews_1 = require("./Messages/GetMessagesViews");
var GetUserPhotos_1 = require("./Users/GetUserPhotos");
var ReadHistory_1 = require("./Messages/ReadHistory");
var ReadMentions_1 = require("./Messages/ReadMentions");
var ReadMessageContents_1 = require("./Messages/ReadMessageContents");
var UnpinAllMessages_1 = require("./Messages/UnpinAllMessages");
var PinMessage_1 = require("./Messages/PinMessage");
var DeleteHistory_1 = require("./Messages/DeleteHistory");
var DeleteUserHistory_1 = require("./Messages/DeleteUserHistory");
var EditAdmin_1 = require("./Chats/EditAdmin");
var EditBanned_1 = require("./Chats/EditBanned");
var EditPhoto_1 = require("./Media/EditPhoto");
var EditTitle_1 = require("./Chats/EditTitle");
var ExportMessageLink_1 = require("./Messages/ExportMessageLink");
var GetAdminedPublicChannels_1 = require("./Chats/GetAdminedPublicChannels");
var GetAdminLog_1 = require("./Chats/GetAdminLog");
var GetChannels_1 = require("./Chats/GetChannels");
var GetFullChat_1 = require("./Chats/GetFullChat");
var GetGroupsForDiscussion_1 = require("./Chats/GetGroupsForDiscussion");
var GetInactiveChannels_1 = require("./Chats/GetInactiveChannels");
var GetLeftChannels_1 = require("./Chats/GetLeftChannels");
var SendMedia_1 = require("./Media/SendMedia");
var SendPhoto_1 = require("./Media/SendPhoto");
var SendDocument_1 = require("./Media/SendDocument");
var SendSticker_1 = require("./Media/SendSticker");
var GetParticipant_1 = require("./Chats/GetParticipant");
var GetChatMembersCount_1 = require("./Chats/GetChatMembersCount");
var GetParticipants_1 = require("./Chats/GetParticipants");
var AnswerInlineQuery_1 = require("./Bots/AnswerInlineQuery");
var _SnakeClient;
var Telegram = /** @class */ (function () {
    function Telegram(SnakeClient) {
        _SnakeClient = SnakeClient;
    }
    Object.defineProperty(Telegram.prototype, "SnakeClient", {
        get: function () {
            return _SnakeClient;
        },
        enumerable: false,
        configurable: true
    });
    // getEntity
    Telegram.prototype.getEntity = function (chatId, useCache) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, (0, GetEntity_1.GetEntity)(this.SnakeClient, chatId, useCache)];
                    case 1: return [2 /*return*/, _a.sent()];
                }
            });
        });
    };
    // getMe
    Telegram.prototype.getMe = function () {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.getEntity('me')];
                    case 1: return [2 /*return*/, _a.sent()];
                }
            });
        });
    };
    // sendMessage
    Telegram.prototype.sendMessage = function (chatId, text, more) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, (0, sendMessage_1.sendMessage)(this.SnakeClient, chatId, text, more)];
                    case 1: return [2 /*return*/, _a.sent()];
                }
            });
        });
    };
    // deleteMessages
    /**
     * This method allow you to deletes messages by their identifiers
     * @param {number|string|bigint} chatId - User or chat, where is the message located.
     * @param {Array} messageId - Message ID list which will be deleted.
     * ```ts
     * bot.command("delete", async (ctx) => {
     *     let results = await ctx.telegram.deleteMessages(ctx.chat.id,[ctx.id])
     *     return console.log(results)
     * })
     * ```
     */
    Telegram.prototype.deleteMessages = function (chatId, messageId) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, (0, DeleteMessages_1.DeleteMessages)(this.SnakeClient, chatId, messageId)];
                    case 1: return [2 /*return*/, _a.sent()];
                }
            });
        });
    };
    // editMessage
    /**
     * This method allow you to edit a message.
     * @param snakeClient - Client
     * @param {number|string|bigint} chatId - Chat/Groups/Channel id.
     * @param {number} messageId - Message id to be edited.
     * @param {string} text - New Message/Caption. You can pass with blank string (`""`) if you want to edit media.
     * @param {Object} more - more parameters to use.
     */
    Telegram.prototype.editMessage = function (chatId, messageId, text, more) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, (0, EditMessage_1.EditMessage)(this.SnakeClient, chatId, messageId, text, more)];
                    case 1: return [2 /*return*/, _a.sent()];
                }
            });
        });
    };
    // forwardMessages
    /**
     * Forwards messages by their IDs.
     * @param {number|string|bigint} chatId - Destination.
     * @param {number|string|bigint} fromChatId - Source of messages.
     * @param {Array} messageId - IDs of messages which will forwarded.
     * @param {Object} more - more paramaters to use.
     * ```ts
     * bot.command("forward", async (ctx) => {
     *     let results = await ctx.telegram.forwardMessages(ctx.chat.id,ctx.chat.id,[ctx.id])
     *     return console.log(results)
     * })
     * ```
     */
    Telegram.prototype.forwardMessages = function (chatId, fromChatId, messageId, more) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, (0, ForwardMessages_1.ForwardMessages)(this.SnakeClient, chatId, fromChatId, messageId, more)];
                    case 1: return [2 /*return*/, _a.sent()];
                }
            });
        });
    };
    // getMessages
    /**
     * Returns the list of messages by their IDs.
     * @param {bigint|number|string} chatId - Chat/Groups/Channel id.
     * @param {Array} messageId - Message Id.
     * @param {boolean} replies - if `true` it will getting the nested reply. and will making floodwait.
     * ```ts
     *   bot.command("getMessages",async (ctx)=>{
     *       let results = await ctx.telegram.getMessages(ctx.chat.id,[ctx.id])
     *       console.log(results)
     *   })
     * ```
     */
    Telegram.prototype.getMessages = function (chatId, messageId, replies) {
        if (replies === void 0) { replies = true; }
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, (0, GetMessages_1.GetMessages)(this.SnakeClient, chatId, messageId, replies)];
                    case 1: return [2 /*return*/, _a.sent()];
                }
            });
        });
    };
    // getMessagesViews
    /**
     * Get and increase the view counter of a message sent or forwarded from a channel.
     * @param {number|string|bigint} chatId - Where the message was found.
     * @param {Array} messageId - IDs of message.
     * @param {boolean} increment - Whether to mark the message as viewed and increment the view counter
     * ```ts
     * bot.command("getMessagesViews",async (ctx)=>{
     *     let results = await ctx.telegram.getMessagesViews(ctx.chat.id,[ctx.id])
     *     console.log(results)
     * })
     * ```
     */
    Telegram.prototype.getMessagesViews = function (chatId, messageId, increment) {
        if (increment === void 0) { increment = false; }
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, (0, GetMessagesViews_1.GetMessagesViews)(this.SnakeClient, chatId, messageId, increment)];
                    case 1: return [2 /*return*/, _a.sent()];
                }
            });
        });
    };
    // getUserPhotos
    /**
     * Getting all user profile photos.
     * @param {number|string|bigint} userId - id of user.
     * @param {Object} more - more object for getUserPhotos
     * ```ts
     * bot.command("getUserPhotos",async (ctx)=>{
     *     let results = await ctx.telegram.getUserPhotos(ctx.from.id)
     *     console.log(results)
     * })
     * ```
     */
    Telegram.prototype.getUserPhotos = function (chatId, more) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, (0, GetUserPhotos_1.GetUserPhotos)(this.SnakeClient, chatId, more)];
                    case 1: return [2 /*return*/, _a.sent()];
                }
            });
        });
    };
    // readHistory
    /**
     * Marks message history as read.
     * @param {bigint|number|string} chatId - Target user or group.
     * @param {Object} more - more parameter for ReadHistory.
     * ```ts
     * bot.command("readHistory",async (ctx)=>{
     *     let results = await ctx.telegram.readHistory(ctx.chat.id,ctx.id)
     *     console.log(results)
     * })
     * ```
     */
    Telegram.prototype.readHistory = function (chatId, more) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, (0, ReadHistory_1.ReadHistory)(this.SnakeClient, chatId, more)];
                    case 1: return [2 /*return*/, _a.sent()];
                }
            });
        });
    };
    // readMentions
    /**
     * Mark mentions as read.
     * @param {string|number|bigint} chatId - Chat/Groups/Channel id.
     * ```ts
     * bot.command("readMentions",async (ctx)=>{
     *     let results = await ctx.telegram.readMentions(ctx.chat.id)
     *     console.log(results)
     * })
     * ```
     */
    Telegram.prototype.readMentions = function (chatId) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, (0, ReadMentions_1.ReadMentions)(this.SnakeClient, chatId)];
                    case 1: return [2 /*return*/, _a.sent()];
                }
            });
        });
    };
    // readMessageContents
    /**
     * Notifies the sender about the recipient having listened a voice message or watched a video.
     * @param {Array} messageId - message ids
     * ```ts
     * bot.on("message",async (ctx)=>{
     *     if(ctx.media){
     *         let results = await ctx.telegram.readMessageContents([ctx.id])
     *         console.log(results)
     *     }
     * })
     * ```
     */
    Telegram.prototype.readMessageContents = function (messageId) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, (0, ReadMessageContents_1.ReadMessageContents)(this.SnakeClient, messageId)];
                    case 1: return [2 /*return*/, _a.sent()];
                }
            });
        });
    };
    // unpinAllMessages
    /**
     * Unpin all message in chats.
     * @param {string|number|bigint} chatId - Chat/Groups/Channel id.
     * ```ts
     * bot.command("unpinAll",async (ctx)=>{
     *     let results = await ctx.telegram.unpinAllMessages(ctx.chat.id)
     *     console.log(results)
     * })
     * ```
     */
    Telegram.prototype.unpinAllMessages = function (chatId) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, (0, UnpinAllMessages_1.UnpinAllMessages)(this.SnakeClient, chatId)];
                    case 1: return [2 /*return*/, _a.sent()];
                }
            });
        });
    };
    // pinMessages
    /**
     * Pin or unpin a message.
     * @param {number|string|bigint} chatId - where to pin or unpin the message.
     * @param {number} messageId - The message to pin or unpin
     * @param {Object} more - more parameter for PinMessage
     * ```ts
     * bot.command("pin",async (ctx)=>{
     *     let results = await ctx.telegram.pinMessage(ctx.chat.id,ctx.id)
     *     console.log(results)
     * })
     * // unpin a message
     * bot.command("unpin",async (ctx)=>{
     *     if(ctx.replyToMessage){
     *         let results = await ctx.telegram.unpinMessage(ctx.chat.id,ctx.replyToMessage.id)
     *         console.log(results)
     *     }
     * })
     * ```
     */
    Telegram.prototype.pinMessages = function (chatId, messageId, more) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, (0, PinMessage_1.PinMessage)(this.SnakeClient, chatId, messageId, more)];
                    case 1: return [2 /*return*/, _a.sent()];
                }
            });
        });
    };
    // unpinMessages
    /**
     * unpin a message.
     * @param {number|string|bigint} chatId - where to pin or unpin the message.
     * @param {number} messageId - The message to pin or unpin
     * ```ts
     * bot.command("unpin",async (ctx)=>{
     *     if(ctx.replyToMessage){
     *         let results = await ctx.telegram.unpinMessage(ctx.chat.id,ctx.replyToMessage.id)
     *         console.log(results)
     *     }
     * })
     * ```
     */
    Telegram.prototype.unpinMessage = function (chatId, messageId) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, (0, PinMessage_1.PinMessage)(this.SnakeClient, chatId, messageId, { unpin: true })];
                    case 1: return [2 /*return*/, _a.sent()];
                }
            });
        });
    };
    // deleteHistory
    /**
     * This method allow you to deletes communication history.
     * @param {string|number|bigint} chatId - User or chat, communication history of which will be deleted.
     * @param {Object} more - more parameters to use.
     * ```ts
     * bot.command("clear", async (ctx) => {
     *     let results = await ctx.telegram.deleteHistory(ctx.chat.id)
     *     return console.log(results)
     * })
     * ```
     */
    Telegram.prototype.deleteHistory = function (chatId, more) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, (0, DeleteHistory_1.DeleteHistory)(this.SnakeClient, chatId, more)];
                    case 1: return [2 /*return*/, _a.sent()];
                }
            });
        });
    };
    //deleteUserHistory
    /**
     * Delete all messages sent by a certain user in a supergroup
     * @param {number|string|bigint} chatId - supergroup id.
     * @param {number|string|bigint} userId - User whose messages should be deleted.
     * ```ts
     * bot.command("deleteMe", async (ctx) => {
     *     let results = await ctx.telegram.deleteUserHistory(ctx.chat.id,ctx.from.id)
     *     return console.log(results)
     * })
     * ```
     */
    Telegram.prototype.deleteUserHistory = function (chatId, userId) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, (0, DeleteUserHistory_1.DeleteUserHistory)(this.SnakeClient, chatId, userId)];
                    case 1: return [2 /*return*/, _a.sent()];
                }
            });
        });
    };
    // editAdmin
    /**
     * Modify the admin rights of a user in a supergroup/channel.
     * @param {bigint|number|string} chatId - Chat/Channel/Group id.
     * @param {bigint|number|string} userId - User id.
     * @param {Object} - more parameters to use.
     *```ts
     * bot.command("promote",async (ctx) => {
     *    if((!ctx.chat.private) && ctx.replyToMessage){
     *        let results = await ctx.telegram.editAdmin(ctx.chat.id,ctx.replyToMessage.from.id)
     *        console.log(results)
     *    }
     * })
     *```
     * This method will return UpdateNewMessage or UpdateNewChannelMessage if success.
     */
    Telegram.prototype.editAdmin = function (chatId, userId, more) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, (0, EditAdmin_1.EditAdmin)(this.SnakeClient, chatId, userId, more)];
                    case 1: return [2 /*return*/, _a.sent()];
                }
            });
        });
    };
    // editBanned
    /**
     * Ban/unban/kick a user in a supergroup/channel.
     * @param {number|bigint|string} chatId - Chat/Group/Channel id.
     * @param {number|bigint|string} userId - User id.
     * @param {Object} more - more parameters to use.
     * ```ts
     * bot.command("ban",async (ctx) => {
     * if((!ctx.chat.private) && ctx.replyToMessage){
     *   let results = await ctx.telegram.editBanned(ctx.chat.id,ctx.replyToMessage.from.id)
     *   console.log(results)
     * }
     * })
     * ```
     * This method will return UpdateNewMessage or UpdateNewChannelMessage. if success.
     */
    Telegram.prototype.editBanned = function (chatId, userId, more) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, (0, EditBanned_1.EditBanned)(this.SnakeClient, chatId, userId, more)];
                    case 1: return [2 /*return*/, _a.sent()];
                }
            });
        });
    };
    // editPhoto
    /**
     * Change the profile picture of chat.
     * @param {number|string|bigint} chatId - Chat/Groups/Channel which will change the profile picture.
     * @param {string|Buffer} photo - The location where the file is located/Url/The buffer of the file.
     * ```ts
     * bot.command("editPhoto", async (ctx)=>{
     *     if(!ctx.chat.private){
     *         let results = await ctx.telegram.editPhoto(ctx.chat.id,"https://tgsnake.js.org/images/tgsnake.jpg")
     *         console.log(results)
     *     }
     * })
     * ```
     */
    Telegram.prototype.editPhoto = function (chatId, photo) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, (0, EditPhoto_1.EditPhoto)(this.SnakeClient, chatId, photo)];
                    case 1: return [2 /*return*/, _a.sent()];
                }
            });
        });
    };
    /**
     * edit chat/group/channel title.
     * @param {bigint|number|string} chatId - Chat/Groups/Channel id.
     * @param {string} title - New title.
     * ```ts
     * bot.command("editTitle",async (ctx) => {
     *    if(!ctx.chat.private){
     *        let results = await ctx.telegram.editTitle(ctx.chat.id,"hey new title")
     *        console.log(results)
     *    }
     * })
     * ```
     * This method will return UpdateNewMessage or UpdateNewChannelMessage. if success.
     */
    // editTitle
    Telegram.prototype.editTitle = function (chatId, title) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, (0, EditTitle_1.EditTitle)(this.SnakeClient, chatId, title)];
                    case 1: return [2 /*return*/, _a.sent()];
                }
            });
        });
    };
    // exportMessageLink
    /**
     * Get link and embed info of a message in a channel/supergroup
     * @param {number|string|bigint} chatId - supergroup/channel id.
     * @param {number} messageId - message id.
     * @param {Object} more - more paramaters to use.
     */
    Telegram.prototype.exportMessageLink = function (chatId, messageId, more) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, (0, ExportMessageLink_1.ExportMessageLink)(this.SnakeClient, chatId, messageId, more)];
                    case 1: return [2 /*return*/, _a.sent()];
                }
            });
        });
    };
    // getAdminedPublicChannels
    /**
     * Get channels/supergroups/geogroups we're admin in. Usually called when the user exceeds the limit for owned public channels/supergroups/geogroups, and the user is given the choice to remove one of his channels/supergroups/geogroups.
     * @param {boolean} byLocation - Get geogroups.
     * @param {boolean} checkLimit - If set and the user has reached the limit of owned public channels/supergroups/geogroups, instead of returning the channel list one of the specified errors will be returned. <br/>
     * Useful to check if a new public channel can indeed be created, even before asking the user to enter a channel username to use in channels.checkUsername/channels.updateUsername.
     * ```ts
     * bot.command("getAdminedPublicChannels",async (ctx) => {
     *    if(!ctx.chat.private){
     *        let results = await ctx.telegram.getAdminedPublicChannels()
     *        console.log(results)
     *    }
     * })
     * ```
     */
    Telegram.prototype.getAdminedPublicChannels = function (byLocation, checkLimit) {
        if (byLocation === void 0) { byLocation = true; }
        if (checkLimit === void 0) { checkLimit = true; }
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, (0, GetAdminedPublicChannels_1.GetAdminedPublicChannels)(this.SnakeClient, byLocation, checkLimit)];
                    case 1: return [2 /*return*/, _a.sent()];
                }
            });
        });
    };
    // getAdminLog
    /**
     * Get the admin log of a channel/supergroup.
     * @param snakeClient - Client
     * @param {number|string|bigint} chatId -  Chat/Channel/Group id.
     * @param {Object} more - more parameters to use.
     * ```ts
     * bot.command("getAdminLog",async (ctx) => {
     *     if(!ctx.chat.private){
     *        let results = await ctx.telegram.getAdminLog(ctx.chat.id)
     *        console.log(results)
     *     }
     * })
     * ```
     */
    Telegram.prototype.getAdminLog = function (chatId, more) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, (0, GetAdminLog_1.GetAdminLog)(this.SnakeClient, chatId, more)];
            });
        });
    };
    // getChannels
    /**
     * Get info about channels/supergroups.
     * @param {Array} chatId - List of channel ids.
     * ```ts
     * bot.command("getChannels",async (ctx) => {
     *     let results = await ctx.telegram.getChannels([ctx.chat.id])
     *     console.log(results)
     * })
     * ```
     */
    Telegram.prototype.getChannels = function (chatId) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, (0, GetChannels_1.GetChannels)(this.SnakeClient, chatId)];
                    case 1: return [2 /*return*/, _a.sent()];
                }
            });
        });
    };
    // getFullChat
    /**
     * Returns full chat/channel info according to its ID.
     * @param {number|string|bigint} chatId - Chat/Groups/Channel id.
     * ```ts
     * bot.command("getFullChat",async (ctx) => {
     *     let results = await ctx.telegram.getFullChat(ctx.chat.id)
     * })
     * ```
     */
    Telegram.prototype.getFullChat = function (chatId) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, (0, GetFullChat_1.GetFullChat)(this.SnakeClient, chatId)];
                    case 1: return [2 /*return*/, _a.sent()];
                }
            });
        });
    };
    // getGroupsForDiscussion
    /**
     * Get all groups that can be used as discussion groups.<br/>
     * Returned legacy group chats must be first upgraded to supergroups before they can be set as a discussion group.<br/>
     * To set a returned supergroup as a discussion group, access to its old messages must be enabled using channels.togglePreHistoryHidden, first. <br/>
     * ```ts
     * bot.command("getGroupsForDiscussion",async (ctx) => {
     *     let results = await ctx.telegram.getGroupsForDiscussion()
     *     console.log(results)
     * })
     * ```
     */
    Telegram.prototype.getGroupsForDiscussion = function () {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, (0, GetGroupsForDiscussion_1.GetGroupsForDiscussion)(this.SnakeClient)];
                    case 1: return [2 /*return*/, _a.sent()];
                }
            });
        });
    };
    // getInactiveChannels
    /**
     * Get inactive channels and supergroups.
     * ```ts
     * bot.command("getInactiveChannels",async (ctx) => {
     *     let results = await ctx.telegram.getInactiveChannels()
     *     console.log(results)
     * })
     * ```
     */
    Telegram.prototype.getInactiveChannels = function () {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, (0, GetInactiveChannels_1.GetInactiveChannels)(this.SnakeClient)];
                    case 1: return [2 /*return*/, _a.sent()];
                }
            });
        });
    };
    // getLeftChannels
    /**
     * Get a list of channels/supergroups we left.
     * @param {number} offset - offset of pagination.
     * ```ts
     * bot.command("getLeftChannels",async (ctx) => {
     *     let results = await ctx.telegram.getLeftChannels()
     *     console.log(results)
     * })
     * ```
     */
    Telegram.prototype.getLeftChannels = function (offset) {
        if (offset === void 0) { offset = 0; }
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, (0, GetLeftChannels_1.GetLeftChannels)(this.SnakeClient, offset)];
                    case 1: return [2 /*return*/, _a.sent()];
                }
            });
        });
    };
    // sendMedia
    /**
     * Sending message media.
     * @param {number|string|bigint} chatId - Chat/Groups/Channel id.
     * @param {Object} media - Message Media.
     * @param more - more parameters to use.
     */
    Telegram.prototype.sendMedia = function (chatId, media, more) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, (0, SendMedia_1.SendMedia)(this.SnakeClient, chatId, media, more)];
                    case 1: return [2 /*return*/, _a.sent()];
                }
            });
        });
    };
    // sendPhoto
    /**
     * Sending photo with fileId/file location/url/buffer.
     * @param {number|string|bigint} chatId - Chat/Groups/Channel id.
     * @param {string|Buffer|Object} fileId - FileId/File Location/Url/Buffer
     * @param {Object} more - more parameters to use.
     * ```ts
     * bot.on("message",async (ctx) => {
     *     if(ctx.media && ctx.media.type == "photo"){
     *         let results = await ctx.telegram.sendPhoto(ctx.chat.id,ctx.media.fileId)
     *         console.log(results)
     *     }
     * })
     * ```
     */
    Telegram.prototype.sendPhoto = function (chatId, fileId, more) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, (0, SendPhoto_1.SendPhoto)(this.SnakeClient, chatId, fileId, more)];
                    case 1: return [2 /*return*/, _a.sent()];
                }
            });
        });
    };
    // sendDocument
    /**
     * Sending Document file location/url/buffer.
     * @param {string|number|bigint} chatId - Chat/Groups/Channel id.
     * @param {string|Buffer} fileId - File Location/Url/Buffer .
     * @param {Object} more - more parameters to use.
     * ```ts
     * bot.command("doc",async (ctx) => {
     *     let results = await ctx.telegram.sendDocument(ctx.chat.id,"https://tgsnake.js.org/images/tgsnake.jpg")
     * })
     * ```
     */
    Telegram.prototype.sendDocument = function (chatId, fileId, more) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, (0, SendDocument_1.SendDocument)(this.SnakeClient, chatId, fileId, more)];
                    case 1: return [2 /*return*/, _a.sent()];
                }
            });
        });
    };
    // sendSticker
    /**
     * Sending sticker with fileId/file location/url/buffer.
     * @param {bigint|number|string} chatId - Chat/Groups/Channel id.
     * @param {string|Buffer|Object} fileId - Path file/FileId/Buffer.
     * ```ts
     * bot.on("message",async (ctx) => {
     *     if(ctx.media && ctx.media.type == "sticker"){
     *         let results = await ctx.telegram.sendSticker(ctx.chat.id,ctx.media.fileId)
     *         console.log(results)
     *     }
     * })
     * ```
     */
    Telegram.prototype.sendSticker = function (chatId, fileId) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, (0, SendSticker_1.SendSticker)(this.SnakeClient, chatId, fileId)];
                    case 1: return [2 /*return*/, _a.sent()];
                }
            });
        });
    };
    // getParticipant
    /**
     * Get info about a channel/supergroup participant.
     * @param {number|string|bigint} - Chat or channels id to getting the list of members.
     * @param {number|string|bigint} - Participant to get info about.
     * ```ts
     * bot.command("getChatMember",async (ctx) => {
     *     let results = await ctx.telegram.getParticipant(ctx.chat.id,ctx.from.id) // getChatMember and getParticipant.is same methods.
     *     console.log(results)
     * })
     * ```
     */
    Telegram.prototype.getParticipant = function (chatId, userId) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, (0, GetParticipant_1.GetParticipant)(this.SnakeClient, chatId, userId)];
                    case 1: return [2 /*return*/, _a.sent()];
                }
            });
        });
    };
    // getChatMember
    /**
     * Get info about a channel/supergroup participant.
     * @param {number|string|bigint} - Chat or channels id to getting the list of members.
     * @param {number|string|bigint} - Participant to get info about.
     * ```ts
     * bot.command("getChatMember",async (ctx) => {
     *     let results = await ctx.telegram.getParticipant(ctx.chat.id,ctx.from.id) // getChatMember and getParticipant.is same methods.
     *     console.log(results)
     * })
     * ```
     */
    Telegram.prototype.getChatMember = function (chatId, userId) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, (0, GetParticipant_1.GetParticipant)(this.SnakeClient, chatId, userId)];
                    case 1: return [2 /*return*/, _a.sent()];
                }
            });
        });
    };
    // getChatMembersCount
    /**
     * Get the number of members in a chat.
     * @param {number|string|bigint} chatId - Chat or channels id to getting the number of members.
     * ```ts
     * bot.command("getChatMembersCount",async (ctx) => {
     *     let results = await ctx.telegram.getChatMembersCount(ctx.chat.id)
     *     console.log(results)
     * })
     * ```
     */
    Telegram.prototype.getChatMembersCount = function (chatId) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, (0, GetChatMembersCount_1.GetChatMembersCount)(this.SnakeClient, chatId)];
                    case 1: return [2 /*return*/, _a.sent()];
                }
            });
        });
    };
    // getParticipants
    /**
     * Getting list from all participants in channel or chats.
     * @param {number|string|bigint} chatId - Chat or channels id to getting the list of members.
     * @param {Object} more - more parameters to use.
     * ```ts
     * bot.command("getChatMembers",async (ctx) => {
     *     let results = await ctx.telegram.getParticipants(ctx.chat.id) // getChatMembers and getParticipants is same methods.
     *     console.log(results)
     * })
     * ```
     */
    Telegram.prototype.getParticipants = function (chatId, more) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, (0, GetParticipants_1.GetParticipants)(this.SnakeClient, chatId, more)];
                    case 1: return [2 /*return*/, _a.sent()];
                }
            });
        });
    };
    // getChatMembers
    /**
     * Getting list from all participants in channel or chats.
     * @param {number|string|bigint} chatId - Chat or channels id to getting the list of members.
     * @param {Object} more - more parameters to use.
     * ```ts
     * bot.command("getChatMembers",async (ctx) => {
     *     let results = await ctx.telegram.getParticipants(ctx.chat.id) // getChatMembers and getParticipants is same methods.
     *     console.log(results)
     * })
     * ```
     */
    Telegram.prototype.getChatMembers = function (chatId, more) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, (0, GetParticipants_1.GetParticipants)(this.SnakeClient, chatId, more)];
                    case 1: return [2 /*return*/, _a.sent()];
                }
            });
        });
    };
    // answerInlineQuery
    Telegram.prototype.answerInlineQuery = function (queryId, results, more) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, (0, AnswerInlineQuery_1.AnswerInlineQuery)(this.SnakeClient, queryId, results, more)];
                    case 1: return [2 /*return*/, _a.sent()];
                }
            });
        });
    };
    return Telegram;
}());
exports.Telegram = Telegram;
